% Encoder of Raptor code in RFC5053( 3GPP Multimedia Broadcast/Multicast Services standard)
% ---------------------------------------
% Created on Thu Mar 14 18:09:44 2019
% @author: HeL
% ---------------------------------------

% function   [G_LT_all, Symbol_all] = encode (K)

% clear;
global Q ;
global L;
global L_prime ;
global V0 ;
global V1 ;
global J ;
global G_LDPC;
global G_Half;
global S;
global H;
global Num_repair;

V0_V1_J;
Q = 65521;

K = 1000 ;
Num_repair = K ;
N_max = K + Num_repair ; 
Source_Symbol = randi([0,1],1,K);


%% Intermediate symbol generation

%%%%%%%%%%%%--------- Pre-Coding Relationships ---------%%%%%%%%%%%

% C denotes the intermediate symbols.
% C[0],...,C[L-1] consist of K common symbols,
% S LDPC symbols and H Half symbols. L = K + S + H.
% X = the smallest positive integer such that X*(X-1) >= 2*K.
% S = the smallest prime integer such that S >= ceil(0.01*K) + X.
% H = the smallest integer such that choose(H,ceil(H/2)) >= K + S.

X = ceil (  ( 1 + sqrt(1+8*K) )/2  );
S = ceil(0.01*K) + X ; 
while (1)
    if isprime(S)
        break;   
    else
        S = S + 1;
    end    
end

H = 2;
search_step = 10;
while (1)
    if nchoosek(H,ceil(H/2)) >= K + S
        if search_step == 1 || H == 2
            break;
        else
            H = H - search_step;
            search_step = search_step/10;
            H = H + search_step;
        end
    else
        H = H + search_step;
    end    
end

H_s = ceil(H/2);
L = K + S + H;
C = zeros(1, L);
L_prime = L ;  % the smallest prime that is greater than or equal to L
while (1)
    if isprime(L_prime)
        break;
    else
        L_prime = L_prime + 1;
    end    
end

% Define S LDPC symbols and G_LDPC
G_LDPC = zeros(S,K);
for i = 0: K-1
    a = 1 + mod( floor(i/S) , (S-1) );
    b = mod(i , S);
    C(K + b + 1) = bitxor( C(K + b + 1) , C(i + 1) ); 
    G_LDPC(b+1,i+1) = bitxor( G_LDPC(b+1,i+1) , 1 );
    b = mod( b + a , S);
    C(K + b + 1) = bitxor( C(K + b + 1) , C(i + 1) );
    G_LDPC(b+1,i+1) = bitxor( G_LDPC(b+1,i+1) , 1 );
    b = mod( b + a , S);
    C(K + b + 1) = bitxor( C(K + b + 1) , C(i + 1) );
    G_LDPC(b+1,i+1) = bitxor( G_LDPC(b+1,i+1) , 1 );
end

% Define H Half symbols and G_Half.
% g[i] is the Gray sequence,m[k] denote the subsequence of g[.] 
% whose elements have exactly k non-zero bits,
% only m[H_s] should be used to define H Half symbols,
% we should begin the search from the Gray sequence 
% whose effective digits is H_s. And m[H_s] need to have K+S elements.

m_Hs = zeros(K+S, H);
G_Half = zeros(H,K+S);
num_of_element = 0;
ii = 2^(H_s-1);
while (1)
    g_i= bitxor( ii , floor(ii/2) );
    g_i_bin = de2bi(g_i,H);
    num_of_1 = length( find(g_i_bin == 1) );
    if num_of_1 == H_s
        num_of_element = num_of_element + 1;
        m_Hs(num_of_element,:) = g_i_bin;
        if num_of_element == K+S
            break;
        end
    end  
    ii = ii + 1;
end

for h = 1:H
    for j = 1:K+S
        element = m_Hs(j,:);
        if element(h) == 1
            C(h + K + S) = bitxor( C(h + K + S) , C(j) );
            G_Half(h,j) = bitxor( G_Half(h,j) , 1 );
        end
    end
end


%%%%%%%%%%%%--------- symbol triples ---------%%%%%%%%%%%
% Each of the K source symbols is associated with a triple (d[i], a[i],
% b[i]) for 0 <= i < K. 
% Each of the repair symbols is associated with a triple (d[i], a[i],
% b[i]) for i >= K.

d_Triple = zeros(1,N_max);
a_Triple = zeros(1,N_max);
b_Triple = zeros(1,N_max);
for ii = 1: N_max
    [ d_Triple(ii), a_Triple(ii), b_Triple(ii) ] = Triple(K, ii-1);
end

% Define G_LT_source for C to generate source symbols.
G_LT_source = zeros(K, L);
for ESI = 1 : K
    
    d_i = d_Triple(ESI);
    a_i = a_Triple(ESI);
    b_i = b_Triple(ESI);  
    
    while b_i >= L 
        b_i = mod(b_i + a_i, L_prime);
    end
    G_LT_source( ESI, b_i + 1 ) = 1;
    
    for j = 1 : min(d_i-1, L-1)
        b_i = mod(b_i + a_i, L_prime);
        while b_i >= L
            b_i = mod(b_i + a_i, L_prime);
        end
        G_LT_source( ESI, b_i + 1 ) = bitxor( G_LT_source(ESI, b_i + 1), 1 );
    end    
    
end

%%%%%%%%%%%%--------- Intermediate Symbols ---------%%%%%%%%%%%
% Intermediate Symbols is the intput symbol of
% an LTencoder whose output symbols are source symbols.

D = [zeros(1,H + S), Source_Symbol]';
I_S = eye(S);
I_H = eye(H);
A_mat = [
        G_LDPC, I_S, zeros(S,H);
        G_Half,  I_H;
        G_LT_source];
    
% A_mat_inv = inv_bin(A_mat);          % inv_bin is the conventional method to get the inverse matrix of A_mat,
% C = multiply_bin( A_mat_inv , D );   % which takes a long time when dimention is large .

C = solve_by_decoder(A_mat, D);        % obtain C by the decoder, which is much faster

%% LT Encoding
% the encoding symbol with ESI X is generated by applying 
% the generator LTEnc[K, (C[0], C[1],...,% C[L-1]), (d, a, b)],
% where (d, a, b) is the encoding symbol triple and X >= K.
% When 0 <= X < K£¬the symbol is a source symbol, no need to 
% produce source symbols, when X >= K, the symbol is a repair symbol,
% we need to generate it with LTencoder.
% but Generation Matrix for both source and repair symbol is needed.  

G_LT_repair = zeros(Num_repair, L);
Repair_Symbol = zeros(1, Num_repair);
for ESI = 1 : Num_repair
    
    d_i = d_Triple(ESI + K);
    a_i = a_Triple(ESI + K);
    b_i = b_Triple(ESI + K);  
    
    while b_i >= L 
        b_i = mod(b_i + a_i, L_prime);
    end
    result = C(b_i + 1);
    G_LT_repair( ESI, b_i + 1 ) = 1;
    
    for j = 1 : min(d_i-1, L-1)
        b_i = mod(b_i + a_i, L_prime);
        while b_i >= L
            b_i = mod(b_i + a_i, L_prime);
        end
        result = bitxor( result , C(b_i + 1) );
        G_LT_repair( ESI, b_i + 1 ) = bitxor( G_LT_repair(ESI, b_i + 1), 1 );
    end
    Repair_Symbol(ESI) = result;
    
end

G_LT_all = [G_LT_source;G_LT_repair];
Symbol_all = [Source_Symbol,Repair_Symbol];













 



    
    












    
    
    
    
